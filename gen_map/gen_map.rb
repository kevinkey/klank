#!/usr/bin/env ruby

# install graphviz (https://graphviz.org/download/)
# install ruby 2.5 with devkit -- if not already done 
# 'gem install bundler' -- if not already done 
# 'bundle install' -- if not already done

# The graphviz executable should be in your path.
# If not, try uncommenting and updating the following:
# ENV["PATH"] = ENV["PATH"].split(";").push('C:\Program Files\Graphviz 2.44.1\bin').join(";")

# For now, if you want to use a randomly generated map
# with Klank, I would suggest something like the following:
# 1) generate a rand map (map_###.png)
# 2) send it out via Teams, Zoom, etc.
# 3) let everyone review it, and agree on it
# 4) copy the map_###.yml to a slot for the game server to use and restart the server.
#
# You should definitely review any map generated as sometimes
# closed loops can be generated that can only accessed via 'teleport'.
# Additionally, the map layout generated by graphvbiz can 
# sometimes be a little confusing (even for valid maps.)


# make sure we have and are using the gem/versions from gemfile
require 'rubygems'
require 'bundler/setup'

# require any needed gems
require 'yaml'

# these are the possible numbers of ranks (floors) above and below ground
ABOVE_RANKS_RANGE = [3,4]
BELOW_RANKS_RANGE = [4,5]
# when a path between rooms is generated, these are the 
# possible attack/move value distrubutions (map2 has a 3 atk path)
# map1: 60 paths: move: 47=1, 13=2: atk: 42=0 12=1, 5=2, 0=3
# map2: 63 paths: move: 58=1, 5=2: atk: 45=0 14=1, 3=2, 1=3
ATTACK_RANGE = [0]*40 + [1]*10 + [2]*5 + [3]*1 
MOVE_RANGE = [1,1,1,1,2]

# This returns true if the room_num is 'invalid' or has already
# been used for something else.
# Set cc_ok to false to ignore crystal caves (heals, minor, major, artifacts can be in cc).
# Set store_ok to false to ignore stores (minor, major, artifacts can be in stores).
def room_used(map, room_num, cc_ok = true, store_ok = true)
	max_room = map['rooms'].count
	used =  (room_num < 2) ||  # nothing in start room!
			(room_num > max_room) ||  # nothing past end room!
			(map['rooms'][room_num]['crystal-cave'] && cc_ok) ||
			(map['rooms'][room_num]['store'] && store_ok) ||
			(map['rooms'][room_num]['major-secrets'] > 0) ||
			(map['rooms'][room_num]['minor-secrets'] > 0) ||
			(map['rooms'][room_num]['monkey-idols'] > 0) ||
			(map['rooms'][room_num]['heal'] > 0) ||
			(map['rooms'][room_num]['artifact'] > 0)
	return used
end

# return the set of rooms reachable from room_num
def rooms_reachable(map, room_num)
	reachable = [ ]
	check = [ room_num ]
	while check.count > 0
		s = check.shift
		next if reachable.include?(s)
		reachable << s
		keys = map['paths'].keys
		keys.each do |key|
			key =~ /^(\d+)-(\d+)$/
			n1, n2 = $1.to_i, $2.to_i
			if map['paths'][key]['one-way'] 
				check |= [n2] if (n1 == s)
			elsif (n1 == s)
				check |= [n2]
			elsif (n2 == s)
				check |= [n1]
			end
		end
	end
	# puts "#{room_num}:  " + reachable.join(',')
	return reachable
end

# return count of paths in for room_num
def paths_in(map, room_num)
	count = 0
	keys = map['paths'].keys
	keys.each do |key|
		key =~ /^(\d+)-(\d+)$/
		n1, n2 = $1.to_i, $2.to_i
		if map['paths'][key]['one-way'] 
			if (n2 == room_num)
				count += 1
			end
		elsif ((n1 == room_num) || (n2 == room_num))
			count += 1
		end
	end
	return count
end

# return count of paths out for room_num
def paths_out(map, room_num)
	count = 0
	keys = map['paths'].keys
	keys.each do |key|
		key =~ /^(\d+)-(\d+)$/
		n1, n2 = $1.to_i, $2.to_i
		if map['paths'][key]['one-way'] 
			if (n1 == room_num)
				count += 1
			end
		elsif ((n1 == room_num) || (n2 == room_num))
			count += 1
		end
	end
	return count
end

# add a path between rooms s and e
# unless specified, the move and attack values for the path
# are taken randomly from the available ranges.
def add_path(map, s, e, move = MOVE_RANGE.sample(), atk = ATTACK_RANGE.sample())
	# delete any old paths (in either direction)
	key = "#{e}-#{s}"
	map['paths'].delete(key)
	key = "#{s}-#{e}"
	map['paths'].delete(key)

	# if after first 2/3 of above ground, add lock based on path value
	# simple heuristic based on two base maps
	val = ((map['rooms'][s]['artifact'] + map['rooms'][e]['artifact'] + 
	       (room_used(map, s) ? 5 : 0) + (room_used(map, e) ? 5 : 0)) / 13).to_i
	locked = (s >= (map['depths'] / 1.5)) && (rand(1..(7 - val)) == 1)

	# if after first few rooms, make 1 in 4 paths one-way
	# or if path to monkey-idol room
	# simple heuristic based on two base maps
	idols = map['rooms'][s]['monkey-idols'] + map['rooms'][e]['monkey-idols']
	one_way = false
	if (idols > 0) || ((s > 4) && (rand(1..4) == 1))
		if (rand(1..2) == 1)
			key = "#{e}-#{s}"
		end
		one_way = true
	end

	# locked paths never have extra move or attacks
	if (locked)
		move = 1
		atk = 0
	end
	# extra move paths never have more than 1 atk
	if (move > 1) && (atk > 1)
		atk = 1
	end
	# one-way paths can have extra move or atk, but not both
	if (one_way && (move > 1) && (atk > 0))
		if (rand(1..2) == 1)
			move = 1
		else
			atk = 0
		end
	end

	map['paths'][key] = {
		'move' => move,
		'attack' => atk,
		'locked' => locked,
		'one-way' => one_way
	}

	return key
end

module KlankMapGen
	require_relative 'map_graph.rb'

	#####################
	# generate images for our two base maps
	#####################
	map_file = 'map1.yml'
	map1 = Map.new(map_file, true, false)  # use a dark color scheme and no images
	map1.generate_map_graph()
	puts "generated graph for #{map_file}"

	map_file = 'map2.yml'
	map2 = Map.new(map_file)  # use light color scheme and no images
	map2.generate_map_graph()
	puts "generated graph for #{map_file}"

	#####################
	# now try generating a "random" map
	#####################

	seed = Time.now.to_i
	# tbd ksh !!! set fixed seed to debug a map
	# seed = 1603823048
	srand(seed)

	rand_map = { }
	room_num = 0

	rand_map['description'] = "This is a random map from seed #{seed}."
	rand_map['depths'] = 0
	rand_map['rooms'] = {}
	rand_map['paths'] = {}

	# rank 1/room 1 reserved for start room
	above_ranks = ABOVE_RANKS_RANGE.sample()
	above_step = rand(4..5)
	above_count = above_step * above_ranks  # not including room 1
	below_ranks = BELOW_RANKS_RANGE.sample()
	below_step = rand(5..6)
	below_count = below_step * below_ranks
	total_count = 1 + above_count + below_count  # includes room 1
	total_ranks = 1 + above_ranks + below_ranks  # includes rank 1

	rand_map['depths'] = 1 + above_count + 1  # which room depths start on

	# generate all the rooms empty
	(1..total_count).each do |room_num|
		rand_map['rooms'][room_num] = {
			'major-secrets' => 0,
			'minor-secrets' => 0,
			'monkey-idols' => 0,
			'heal' => 0,
			'artifact' => 0,
			'crystal-cave' => false,
			'store' => false
		}.merge(rand_map['rooms'][room_num] || {})
	end

	# make some rooms crystal caves (avg 1 per rank + 2)
	# also *try* not put them next to each other (it can still
	# happen since we only check prev room, but this helps
	# spread them out)
	(1..total_ranks+2).each do |i|
		loop do
			room_num = rand(2..total_count)
			next if rand_map['rooms'][room_num-1]['crystal-cave']
			break if !room_used(rand_map, room_num)
		end
		rand_map['rooms'][room_num]['crystal-cave'] = true
	end    

	# make 4 rooms stores
	(1..4).each do |i|
		# we want these to tend to be toward middle of board
		loop do
			room_num = (total_count / 2) + (rand(0..rand(1..total_count/2)) * [-1,1].sample())
			break if !room_used(rand_map, room_num)
		end
		rand_map['rooms'][room_num]['store'] = true
	end    

	# 7 rooms in the depths should have artifacts
	[ 30, 25, 20, 15, 10 , 7, 5 ].each_with_index do |artifact, i|
		# we want these to tend to be especially 'deeper'
		limit = 1000
		loop do
			limit -= 1
			room_num = 1 + above_count + below_count - rand(0..rand(0..rand(0..below_count))) - (i*3)
			# also try to spread them out
			next if (room_num < (1 + above_count)) || (rand_map['rooms'][room_num-1]['artifact'] > 0)
			# NB artifacts can be in crystal caves and stores
			break if (limit <= 0) || (!room_used(rand_map, room_num, false, false) && (room_num > (1 + above_count)))
		end
		rand_map['rooms'][room_num]['artifact'] = artifact
	end

	# make 1-2 heal rooms (more likely 2 heal rooms)
	num_heal_rooms = [1,2,2].sample()
	(1..num_heal_rooms).each do |i|
		# we want these to tend to be 'deeper'
		loop do
			room_num = total_count - rand(0..rand(0..total_count-1))
			# NB heal rooms can be in crystal caves
			break if !room_used(rand_map, room_num, false)
		end
		rand_map['rooms'][room_num]['heal'] = 1
	end    

	# make a monkey idol room in the depths
	loop do
		room_num = 1 + above_count + rand(1..below_count)
		break if !room_used(rand_map, room_num)
	end
	rand_map['rooms'][room_num]['monkey-idols'] = 3

	# 9 rooms should have 1 major secret
	(1..9).each do |i|
		loop do
			# want these to tend to be deeper
			room_num = rand(2..total_count) + (i*1.5).to_i
			# NB major secrets can be in crystal caves and stores
			break if !room_used(rand_map, room_num, false, false)
		end
		rand_map['rooms'][room_num]['major-secrets'] = 1
	end    

	# 9 rooms should have 2 minor secrets	
	(1..9).each do |i|
		loop do
			# want these to tend to be shallower
			room_num = rand(2..total_count) - (i*1.5).to_i
			# NB minor secrets can be in crystal caves and stores
			break if !room_used(rand_map, room_num, false, false)
		end
		rand_map['rooms'][room_num]['minor-secrets'] = 2
	end    

	# room 1 always connected to room 2
	add_path(rand_map, 1, 2, 1, 0)

	# one rank should have a wrap around path
	wrap_rank = rand(2..total_ranks)
	(2..total_ranks).each do |rank|

		# figure out room start/end for this rank
		if (rank <= (1 + above_ranks))
			step = above_step
			room_start = 1 + (rank - 2) * above_step + 1
			room_end = room_start + above_step - 1
		else
			step = below_step
			room_start = 1 + above_count + (rank - above_ranks - 2) * below_step + 1
			room_end = room_start + below_step - 1
		end
		# puts "#{rank}, #{step}, #{room_start}, #{room_end}"

		# wrap rank
		if (rank == wrap_rank)
			key = add_path(rand_map, room_start, room_end, 1, 0)
			# puts "wrap #{key} path"
		end

		# add LR (left-right) paths for this rank
		skipped = false
		(room_start..room_end-1).each do |room_num|
			# after first rank, skip 1 in 5 LR paths, but no more than 1 per rank
			if !skipped && (room_num > above_step) && (rand(1..5) == 1)
				skipped = true
			else
				add_path(rand_map, room_num, room_num+1)
			end
		end
	
		# add UD (up-down) paths for this rank
		if (rank < total_ranks)
			(room_start..room_end).each do |room_num|
				if true && (rand(1..8) == 1) && ((room_num == room_start) || (room_num == room_end))
					# make it a slide going two ranks
					e = room_num + (2 * step)
					e += (below_step - above_step) if (room_num < (1 + above_count)) && (e > (1 + above_count + 1))
					if (e <= total_count)
						key = add_path(rand_map, room_num, e)
						rand_map['paths'][key]['one-way'] = true
						# puts "slide #{key} path"
					end
				else
					e = room_num + step + [-1,0,1].sample()
					e += 2 if (e <= room_end)
					e -= 2 if (e > (room_end + step))
					if (e > room_end) && (e <= (room_end + step))
						add_path(rand_map, room_num, e)
					end
				end
			end
		end

	end

	# do something which can add/delete paths
	# in all cases, we want to make sure all rooms 
	# can make it to/from start
	updated = true
	limit = 10
	while ( updated )

		updated = false

		# check that rooms are reachable from start
		added = true
		while (added)
			added = false
			reachable = rooms_reachable(rand_map, 1)
			(3..total_count).each do |room_num|
				if (!reachable.include?(room_num))
					# try to add one to closest room
					h = reachable.sort.group_by{ |e| e <=> room_num }
					closest = h[-1].last || h[1].first
					key = add_path(rand_map, closest, room_num)
					# puts "no path from start, adding #{key}"
					added = true
					break
				end
			end
		end

		# check that rooms have a path to start
		added = true
		while (added)
			added = false
			(3..total_count).each do |room_num|
				reachable = rooms_reachable(rand_map, room_num)
				next if (reachable.min == 1)
				# try to add one
				key = add_path(rand_map, room_num, room_num-1)
				# puts "no path to start, adding #{key}"
				added = true
			end
		end

		limit -= 1
		break if limit < 0
		
		# make high artifact value rooms a little harder to get to
		(1..total_count).each do |room_num|
			if (rand_map['rooms'][room_num]['artifact'] > 20)
				removed = false
				keys = rand_map['paths'].keys
				keys.each do |key|
					key =~ /^(\d+)-(\d+)$/
					n1, n2 = $1.to_i, $2.to_i
					if ((n1 == room_num) || (n2 == room_num))
						n2 = (n1 == room_num) ? n2 : n1  # set n2 to the "other" room
						# if more than 1 paths in, remove 1
						if ((limit > 4) && !removed && (paths_in(rand_map, room_num) > 1) && (paths_out(rand_map, n2) > 1))
							# tbd ksh !!! we need to be smarter about removing paths here
							# !!! then we could get rid of the limit thing
							# puts "removing #{key} path"
							removed = true
							rand_map['paths'].delete(key)
							updated = true
						elsif (paths_in(rand_map, room_num) == 1)
							# if only one path in, lock it
							# puts "locking #{key} path"
							rand_map['paths'][key]['locked'] = true
							# locked paths never have extra move or attacks
							rand_map['paths'][key]['move'] = 1
							rand_map['paths'][key]['attack'] = 0
						else
							# for all others, 1 of 2 things: make it locked or A2M2
							# puts "hardening #{key} path"
							if (rand(1..2) == 1)
								rand_map['paths'][key]['locked'] = false
								rand_map['paths'][key]['move'] = 2
								rand_map['paths'][key]['attack'] = 2
							else
								rand_map['paths'][key]['locked'] = true
								# locked paths never have extra move or attacks
								rand_map['paths'][key]['move'] = 1
								rand_map['paths'][key]['attack'] = 0
							end
						end
					end
				end
			end
		end

	end

	# now write out yml and image files
	map_file = "map_#{seed}.yml"
	File.open(map_file, 'w') { |file| file.write(rand_map.to_yaml) }
	map3 = Map.new(map_file, true, true)  # use dark color scheme and images
	map3.generate_map_graph()
	puts "generated graph for #{map_file}"

	puts "done...\n"
end